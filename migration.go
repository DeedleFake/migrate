package migration

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"deedles.dev/migration/internal/util"
	"golang.org/x/exp/slices"
)

var (
	ErrIrreversible = errors.New("migration is irreversible")
)

// MigrationFunc is the signature matched by functions that define
// migrations.
type MigrationFunc func(m *M)

// MigrationPlan represents a migration plan generated by the Migrate
// functions. It is intended for internal use.
type MigrationPlan struct {
	schema *schema
	steps  []*M
}

func planUp(ctx context.Context, db *sql.DB, funcs map[string]MigrationFunc, target string) (*MigrationPlan, error) {
	schema, err := loadSchema(ctx, db)
	if err != nil {
		return nil, fmt.Errorf("load schema: %w", err)
	}

	verts := make(map[string]*M, len(funcs))
	for n, f := range funcs {
		if schema.prev.Contains(n) {
			continue
		}

		m := M{name: n}
		f(&m)
		m.deps.RemoveSet(schema.prev)
		verts[n] = &m
	}

	if target != "" {
		lin := lineage(verts, target)
		for n := range verts {
			if !lin.Contains(n) {
				delete(verts, n)
			}
		}
	}

	steps, err := flattenDAG(verts)
	if err != nil {
		return nil, fmt.Errorf("calculate migration order: %w", err)
	}

	return &MigrationPlan{
		schema: schema,
		steps:  steps,
	}, nil
}

// PlanUp produces a migration plan that runs all of the migrations,
// moving the database to the latest schema. It is intended for
// internal use.
func PlanUp(ctx context.Context, db *sql.DB, funcs map[string]MigrationFunc) (*MigrationPlan, error) {
	return planUp(ctx, db, funcs, "")
}

func PlanUpTo(ctx context.Context, db *sql.DB, funcs map[string]MigrationFunc, target string) (*MigrationPlan, error) {
	if _, ok := funcs[target]; !ok {
		return nil, fmt.Errorf("no such migration: %q", target)
	}
	return planUp(ctx, db, funcs, target)
}

func (m *MigrationPlan) Run(ctx context.Context, db *sql.DB, dialect Dialect) error {
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("begin transaction: %w", err)
	}
	defer tx.Rollback()

	for _, step := range m.steps {
		step.deps.RemoveSet(m.schema.prev)
		err := step.migrateUp(ctx, tx, dialect)
		if err != nil {
			return err
		}

		err = m.schema.addPrev(ctx, tx, step.name)
		if err != nil {
			return err
		}
	}

	err = tx.Commit()
	if err != nil {
		return fmt.Errorf("commit transaction: %w", err)
	}

	return nil
}

// Steps returns the names of the migrations that will be run in the
// order that they will be run in. Note that this list includes
// migrations that might be skipped because they've already been run
// previously.
func (m *MigrationPlan) Steps() []string {
	steps := make([]string, 0, len(m.steps))
	for _, s := range m.steps {
		steps = append(steps, s.name)
	}
	return steps
}

func lineage(funcs map[string]*M, target string) *util.Set[string] {
	var lin util.Set[string]

	var inner func(cur string)
	inner = func(cur string) {
		if lin.Contains(cur) {
			return
		}

		lin.Add(cur)
		funcs[cur].deps.Do(func(d string) {
			inner(d)
		})
	}

	return &lin
}

// flattenDAG performs a topological sort on a set of migrations,
// generating a slice of steps that should be run in an order that
// respects the dependency requirements specified by the migration
// functions.
func flattenDAG(verts map[string]*M) (steps []*M, err error) {
	defer func() {
		switch r := recover().(type) {
		case nil:
		case error:
			err = r
		default:
			panic(r)
		}
	}()

	rem := util.SortedKeys(verts) // To ensure determinsitic behavior.
	steps = make([]*M, 0, len(verts))

	var perm util.Set[string]
	var tmp util.Set[string]
	var inner func(*M)
	inner = func(m *M) {
		if perm.Contains(m.name) {
			return
		}
		defer perm.Add(m.name)

		if tmp.Contains(m.name) {
			panic(fmt.Errorf("dependency cycle detected at %q", m.name))
		}
		tmp.Add(m.name)
		defer tmp.Remove(m.name)

		deps := m.deps.Slice()
		slices.Sort(deps) // To ensure deterministic behavior.
		for _, dep := range deps {
			d, ok := verts[dep]
			if !ok {
				panic(fmt.Errorf("migration %q depends on non-existent migration %q", m.name, dep))
			}
			inner(d)
		}

		steps = append(steps, m)
	}

	for perm.Len() < len(rem) {
		for _, name := range rem {
			inner(verts[name])
		}
	}
	return steps, nil
}

// A mstep is a step in a migration. It might create a table, modify a
// column, or do something else entirely.
type mstep interface {
	migrateUp(context.Context, *sql.Tx, Dialect) error
	migrateDown(context.Context, *sql.Tx, Dialect) error
}
